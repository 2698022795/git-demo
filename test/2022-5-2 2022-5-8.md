# Pytorch创建神经网络

**第一步：准备数据集**

```python
train_data = torchvision.datasets.CIFAR10(root='./dataset', train=True, transform=torchvision.transforms.ToTensor(),download=True) # root指定根目录，train指定数据是训练集还是数据集，transform是对原始数据进行一些形状调整，方便神经网络读入，download指定是否下载数据集
```

Pytorch已经内置了常用的数据集和神经网络模型，可以在官网上上找到。附上链接[Datasets — Torchvision 0.12 documentation (pytorch.org)](https://pytorch.org/vision/stable/datasets.html)



**第二步：使用DataLoader加载数据集**

```python
train_dataloader = DataLoader(train_data,batch_size=64，shuffle=True) # 将数据集装入DataLoader中,batch_size设置部分数据用于梯度下降，shuffle指定是否打乱数据集
```



**第三步：搭建/加载神经网络**

```python
# 搭建神经网络（仿写搭建VGG16神经网络）
class MyModule(nn.Module):
    def __init__(self):
        super(MyModule, self).__init__()	
        self.model = nn.Sequential(		#nn.Sequential()简化神经网络编写的过程
            nn.Conv2d(3, 32, 5, 1, 2), 	# nn.Conv2d前五个参数（in_channel，out_channel，卷积核函数，stride，padding）
            nn.MaxPool2d(2),	# 池化核函数2×2
            nn.Conv2d(32, 32, 5, 1, 2),
            nn.MaxPool2d(2),
            nn.Conv2d(32, 64, 5, 1, 2),
            nn.MaxPool2d(2),
            nn.Flatten(),		# 把神经网络拉直
            nn.Linear(64 * 4 * 4, 64),
            nn.Linear(64, 10)
        )

    def forward(self, x):
        x = self.model(x)
        return x
 # 加载模型
from 神经网络类所在文件名 import *  # 加载模型
```

一般情况下，神经网络类中编写init和forward函数。



**第四步：创建网络模型对象**

```python
myModule = MyModule()
```



**第五步：创建损失函数**

```python
loss_fn = nn.CrossEntroyLoss()
```



**第六步：创建优化器**

````python
config = {
    "learning_rate": 1e-2,
    "momentum": 0.9
}
optimizer = torch.optim.SGD(myModule.parameters(), lr=config["learning_rate"], momentum=config["momentum"])
````



**第七步：设置训练网络的一些参数**

```python
# 记录训练的次数
total_train_step = 0
# 记录测试的次数
total_test_step = 0
# 训练的轮数
epoch = 10

# 添加tensorboard
writer = SummaryWriter("logs_train") # tensorboard用于可视化神经网络结构和训练过程，这里的参数指定了tensorboard记录的目录，查看文本的方式是在pycharm的terminal中切换到当前.py文件的目录中，输入命令 tensorboard --logdir=logs_train 会弹出网址，网址中可以实现查看网络结构等操作。
```



**第八步：开始训练**

```python
for i in range(epoch):
    print("------------------------第{}轮训练开始-----------------------".format(i + 1))

    # 训练步骤开始
    myModule.train()  # 不设置也可以训练
    for data in train_dataloader:	# 读取train_dataloader中的data
        imgs, targets = data		# 1.读取data中的imgs,targets
        outputs = myModule(imgs)	# 2.前向传播
        loss = loss_fn(outputs, targets)	# 3. 损失函数计算

        # 优化器优化模型
        optimizer.zero_grad()  # 4.重置梯度值
        loss.backward()  # 5.反向传播
        optimizer.step()  # 6.模型优化

        total_train_step = total_train_step + 1
        if total_train_step % 100 == 0:
            print("训练次数：{},Loss：{}".format(total_train_step, loss.item()))  # 不加item是tensor类型，加了item是数据
            writer.add_scalar("train_loss", loss.item(), total_train_step)	# 这里用上了tensorboard,第一个参数train_loss是可视化的图表的名称,第二个参数loss.item()指定了自变量，第三个参数指定了图表中的某个图。

    # 测试步骤开始(使用tensorboard可以实时查看损失函数走势,使用argmax可以求出outputs中各行的最大值，再与targets比较，进而得出正确率)
    myModule.eval()  # 不设置也可以测试
    total_test_loss = 0
    total_accuracy = 0
    with torch.no_grad():
        for data in test_dataloader: # 读取test_dataloader中的data
            imgs, targets = data	# 1.读取data中的imgs,targets
            outputs = myModule(imgs) # 2.前向传播
            loss = loss_fn(outputs, targets)	# 3，损失函数计算
            total_test_loss = total_test_loss + loss	# 统计损失值
            accuracy = (outputs.argmax(1) == targets).sum()	# 计算准确率
            total_accuracy = total_accuracy + accuracy	# 统计准确率
    print("整体测试集上的Loss:{}".format(total_test_loss))
    print("整体测试集上的正确率:{}".format(total_accuracy / test_data_size))
    writer.add_scalar("test_loss", total_test_loss, total_test_step)	# 这里用上了tensorboard,第一个参数test_loss是可视化的图表的名称,第二个参数total_test_loss指定了自变量，第三个参数指定了图表中的某个图。
    writer.add_scalar("test_accuracy", total_accuracy / test_data_size, total_test_step)	# 这里用上了tensorboard,第一个参数test_accuracy是可视化的图表的名称,第二个参数total_accuracy / test_data_size 指定了自变量，第三个参数指定了图表中的某个图。
    total_test_step = total_test_step + 1

    # 模型保存的方式一
    torch.save(myModule, "mymodule_{}.pth".format(i))
    # 模型保存的方式二
    torch.save(myModule.state_dict(), "mymodule_0.pth".format(i))
    print("模型已经保存")

writer.close()
```



参考视频：[PyTorch深度学习快速入门教程 哔哩哔哩_bilibili(一刷已经完成)](https://www.bilibili.com/video/BV1hE411t7RN)

[Models and pre-trained weights — Torchvision 0.12 documentation (pytorch.org)](https://pytorch.org/vision/stable/models.html#classification)
